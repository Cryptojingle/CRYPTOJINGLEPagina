import { EventEmitter2 } from 'eventemitter2';
import { KeyExchange } from './KeyExchange';
import { SocketService, SocketServiceProps } from './SocketService';
import { CommunicationLayer } from './types/CommunicationLayer';
import { CommunicationLayerMessage } from './types/CommunicationLayerMessage';
import { ConnectToChannelOptions } from './types/ConnectToChannelOptions';
import { DisconnectOptions } from './types/DisconnectOptions';
import { KeyInfo } from './types/KeyInfo';
import { WebRTCLib } from './types/WebRTCLib';
export interface WebRTCServiceProps extends SocketServiceProps {
    webRTCLib?: WebRTCLib;
}
export declare class WebRTCService extends EventEmitter2 implements CommunicationLayer {
    handshakeDone: boolean;
    isOriginator: boolean;
    clientsConnected: boolean;
    clientsReady: boolean;
    socketService: SocketService;
    webrtc?: RTCPeerConnection;
    dataChannel?: RTCDataChannel;
    keyExchange: KeyExchange;
    RTCPeerConnection: any;
    RTCSessionDescription: any;
    RTCIceCandidate: any;
    reconnect?: boolean;
    context: string;
    debug: boolean;
    constructor({ otherPublicKey, webRTCLib, communicationLayerPreference, reconnect, transports, context, ecies, communicationServerUrl, logging, }: WebRTCServiceProps);
    isConnected(): boolean;
    setupWebrtc(): void;
    connectToChannel({ channelId }: ConnectToChannelOptions): void;
    resetKeys(): void;
    keyCheck(): void;
    onMessage(message: {
        data: string;
    }): boolean;
    sendMessage(message: CommunicationLayerMessage): void;
    createChannel(): import("./types/Channel").Channel;
    getKeyInfo(): KeyInfo;
    ping(): void;
    pause(): void;
    resume(): void;
    disconnect(options?: DisconnectOptions): void;
}
//# sourceMappingURL=WebRTCService.d.ts.map