import { EventEmitter2 } from 'eventemitter2';
import { ECIESProps } from './ECIES';
import { Channel } from './types/Channel';
import { CommunicationLayer } from './types/CommunicationLayer';
import { CommunicationLayerMessage } from './types/CommunicationLayerMessage';
import { CommunicationLayerPreference } from './types/CommunicationLayerPreference';
import { ConnectToChannelOptions } from './types/ConnectToChannelOptions';
import { DisconnectOptions } from './types/DisconnectOptions';
import { KeyInfo } from './types/KeyInfo';
import { CommunicationLayerLoggingOptions } from './types/LoggingOptions';
export interface SocketServiceProps {
    communicationLayerPreference: CommunicationLayerPreference;
    reconnect?: boolean;
    transports?: string[];
    otherPublicKey?: string;
    communicationServerUrl: string;
    context: string;
    ecies?: ECIESProps;
    logging?: CommunicationLayerLoggingOptions;
}
export interface RPCMethodResult {
    timestamp: number;
    method: string;
    result?: unknown;
    elapsedTime?: number;
}
export interface RPCMethodCache {
    [id: string]: RPCMethodResult;
}
export declare class SocketService extends EventEmitter2 implements CommunicationLayer {
    private socket;
    private clientsConnected;
    /**
     * Special flag used to session persistence in case MetaMask disconnects without Pause,
     * it means we need to re-create a new key handshake.
     */
    private clientsPaused;
    private isOriginator?;
    private channelId?;
    private keyExchange;
    private manualDisconnect;
    private resumed?;
    private communicationLayerPreference;
    private context;
    private withKeyExchange?;
    private communicationServerUrl;
    private debug;
    private rpcMethodTracker;
    private hasPlaintext;
    constructor({ otherPublicKey, reconnect, communicationLayerPreference, transports, communicationServerUrl, context, ecies, logging, }: SocketServiceProps);
    resetKeys(): void;
    private checkSameId;
    private setupChannelListeners;
    createChannel(): Channel;
    connectToChannel({ channelId, isOriginator, withKeyExchange, }: ConnectToChannelOptions): void;
    getKeyInfo(): KeyInfo;
    keyCheck(): void;
    sendMessage(message: CommunicationLayerMessage): void;
    ping(): void;
    pause(): void;
    isConnected(): boolean;
    resume(): void;
    disconnect(options?: DisconnectOptions): void;
}
//# sourceMappingURL=SocketService.d.ts.map