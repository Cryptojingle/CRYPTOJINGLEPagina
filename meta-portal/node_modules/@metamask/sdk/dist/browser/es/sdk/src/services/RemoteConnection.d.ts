import { AutoConnectOptions, ChannelConfig, CommunicationLayerPreference, DappMetadata, DisconnectOptions, ECIESProps, KeyInfo, RemoteCommunication, StorageManagerProps, WebRTCLib } from '@metamask/sdk-communication-layer';
import { SDKLoggingOptions } from '../types/SDKLoggingOptions';
import { ProviderService } from './ProviderService';
export interface RemoteConnectionProps {
    timer?: {
        runBackgroundTimer?: (cb: () => void, ms: number) => number;
        stopBackgroundTimer?: () => void;
    };
    communicationLayerPreference: CommunicationLayerPreference;
    dappMetadata?: DappMetadata;
    _source?: string;
    enableDebug?: boolean;
    transports?: string[];
    webRTCLib?: WebRTCLib;
    communicationServerUrl?: string;
    ecies?: ECIESProps;
    storage?: StorageManagerProps;
    autoConnect?: AutoConnectOptions;
    logging?: SDKLoggingOptions;
    connectWithExtensionProvider?: () => void;
    modals: {
        onPendingModalDisconnect?: () => void;
        install?: (params: {
            link: string;
            debug?: boolean;
            connectWithExtension?: () => void;
        }) => {
            unmount?: () => void;
            mount?: (link: string) => void;
        };
        otp?: (onDisconnect?: () => void) => {
            mount?: () => void;
            updateOTPValue?: (otpValue: string) => void;
            unmount?: () => void;
        };
    };
}
export declare class RemoteConnection implements ProviderService {
    private connector;
    private universalLink?;
    private developerMode;
    private sentFirstConnect;
    private communicationLayerPreference;
    private pendingModal?;
    private installModal?;
    private options;
    /**
     * Wait for value from metamask mobile
     */
    private otpAnswer?;
    constructor(options: RemoteConnectionProps);
    initializeConnector(): RemoteCommunication;
    getUniversalLink(): string;
    /**
     * Called after a connection is re-established on an existing channel in order to prevent session hijacking.
     *
     * On trusted device (same device as metamask):
     *   - launch deeplink to authorize the channel
     *
     * On untrusted device (webapp):
     *  - ask user to reconnect.
     */
    handleSecureReconnection({ channelConfig, deeplink, }: {
        channelConfig: ChannelConfig;
        deeplink?: boolean;
    }): Promise<void>;
    startConnection(): Promise<boolean>;
    showInstallModal({ link }: {
        link: string;
    }): void;
    getChannelConfig(): ChannelConfig | undefined;
    getKeyInfo(): KeyInfo | undefined;
    getConnector(): RemoteCommunication;
    isConnected(): boolean;
    isAuthorized(): boolean;
    isPaused(): boolean;
    disconnect(options?: DisconnectOptions): void;
}
//# sourceMappingURL=RemoteConnection.d.ts.map